/*
Copyright 2022 Huawei Cloud Computing Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package executor

import (
	"bytes"
)

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
func {{.Name}}MaxReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
	if c.Column(ordinal).NilCount() == 0 {
        // fast path
		maxValue, maxIndex := c.Column(ordinal).{{.Name}}Value(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).{{.Name}}Value(i)
			if v > maxValue || (v == maxValue && c.TimeByIndex(i) < c.TimeByIndex(maxIndex)) {
				maxIndex = i
				maxValue = v
			}
		}
		return maxIndex, maxValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	maxValue, maxIndex := c.Column(ordinal).{{.Name}}Value(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).{{.Name}}Value(i), c.Column(ordinal).GetTimeIndex(i)
		if v > maxValue || (v == maxValue && c.TimeByIndex(index) < c.TimeByIndex(maxIndex)) {
			maxIndex = index
			maxValue = v
		}
	}
	return maxIndex, maxValue, false
}
{{- end}}
{{end}}

func BooleanMaxReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
        // fast path
		maxValue, maxIndex := c.Column(ordinal).BooleanValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if (v != maxValue && v) || (v == maxValue && c.TimeByIndex(i) < c.TimeByIndex(maxIndex)) {
				maxIndex = i
				maxValue = v
			}
		}
		return maxIndex, maxValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	maxValue, maxIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).BooleanValue(i), c.Column(ordinal).GetTimeIndex(i)
		if (v != maxValue && v) || (v == maxValue && c.TimeByIndex(index) < c.TimeByIndex(maxIndex)) {
			maxIndex = index
			maxValue = v
		}
	}
	return maxIndex, maxValue, false
}

{{range .}}
{{- if ne .Name "Boolean"}}
func {{.Name}}LastReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
	if c.Column(ordinal).NilCount() == 0 {
        // fast path
		lastValue, lastIndex := c.Column(ordinal).{{.Name}}Value(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).{{.Name}}Value(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) || 
			    (c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, {{.Nil}}, true
	}
	lastValue, lastIndex := c.Column(ordinal).{{.Name}}Value(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).{{.Name}}Value(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) || 
		    (c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func {{.Name}}LastMerge(prevPoint, currPoint *{{.Name}}Point) {
    {{- if ne .Name "String"}}
	if prevPoint.isNil || (currPoint.time > prevPoint.time) || 
	    (currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
    {{- else}}
    if prevPoint.isNil || (currPoint.time > prevPoint.time) || 
        (currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
    {{- end}}
		prevPoint.Assign(currPoint)
	}
}
{{- end}}
{{end}}

func BooleanLastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
        // fast path
		lastValue, lastIndex := c.Column(ordinal).BooleanValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) || 
			    (c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).BooleanValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) || 
		    (c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v && !lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastMerge(prevPoint, currPoint *BooleanPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) || 
	    (currPoint.time == prevPoint.time && currPoint.value && !prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

{{range .}}
{{- if ne .Name "Boolean"}}
func {{.Name}}FirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
    // fast path
    firstValue, firstIndex := c.Column(ordinal).{{.Name}}Value(start), start
    // column time is not initialized in the subquery
    if len(c.Column(ordinal).ColumnTimes()) == 0 {
        for i := start; i < end; i++ {
            v := c.Column(ordinal).{{.Name}}Value(i)
            if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
                (c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
                firstIndex = i
                firstValue = v
            }
        }
        return firstIndex, firstValue, false
    }
    // column time is initialized
    for i := start; i < end; i++ {
        v := c.Column(ordinal).{{.Name}}Value(i)
        if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
            (c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
            firstIndex = i
            firstValue = v
        }
    }
    return firstIndex, firstValue, false
}

func {{.Name}}FirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, {{.Nil}}, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).{{.Name}}Value(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).{{.Name}}Value(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).{{.Name}}Value(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).{{.Name}}Value(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func {{.Name}}FirstTimeColReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return {{.Name}}FirstTimeColFastReduce(c, ordinal, start, end)
	}
	return {{.Name}}FirstTimeColSlowReduce(c, ordinal, start, end)
}

func {{.Name}}FirstTimeColMerge(prevPoint, currPoint *{{.Name}}Point) {
    {{- if ne .Name "String"}}
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
	    (currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
    {{- else}}
    if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
        (currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
    {{- end}}
		prevPoint.Assign(currPoint)
	}
}
{{- end}}
{{end}}

func BooleanFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
    // fast path
    firstValue, firstIndex := c.Column(ordinal).BooleanValue(start), start
    // column time is not initialized in the subquery
    if len(c.Column(ordinal).ColumnTimes()) == 0 {
        for i := start; i < end; i++ {
            v := c.Column(ordinal).BooleanValue(i)
            if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
                (c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && !v && firstValue) {
                firstIndex = i
                firstValue = v
            }
        }
        return firstIndex, firstValue, false
    }
    for i := start; i < end; i++ {
        v := c.Column(ordinal).BooleanValue(i)
        if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
            (c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && !v && firstValue) {
            firstIndex = i
            firstValue = v
        }
    }
    return firstIndex, firstValue, false
}

func BooleanFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).BooleanValue(vs),  c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).BooleanValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && !v && firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).BooleanValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && !v && firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func BooleanFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
	    return BooleanFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return BooleanFirstTimeColSlowReduce(c, ordinal, start, end)
}

func BooleanFirstTimeColMerge(prevPoint, currPoint *BooleanPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
	(currPoint.time == prevPoint.time && !currPoint.value && prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

{{range .}}
{{- if ne .Name "Boolean"}}
func {{.Name}}LastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
    // fast path
    lastValue, lastIndex := c.Column(ordinal).{{.Name}}Value(start), start
    // column time is not initialized in the subquery
    if len(c.Column(ordinal).ColumnTimes()) == 0 {
        for i := start; i < end; i++ {
            v := c.Column(ordinal).{{.Name}}Value(i)
            if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
                (c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
                lastIndex = i
                lastValue = v
            }
        }
        return lastIndex, lastValue, false
    }
    // column time is initialized
    for i := start; i < end; i++ {
        v := c.Column(ordinal).{{.Name}}Value(i)
        if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
            (c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
            lastIndex = i
            lastValue = v
        }
    }
    return lastIndex, lastValue, false
}

func {{.Name}}LastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, {{.Nil}}, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).{{.Name}}Value(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).{{.Name}}Value(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).{{.Name}}Value(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).{{.Name}}Value(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func {{.Name}}LastTimeColReduce(c Chunk, ordinal, start, end int) (int, {{.Type}}, bool) {
	if c.Column(ordinal).NilCount() == 0 {
	    return {{.Name}}LastTimeColFastReduce(c, ordinal, start, end)
	}
	return {{.Name}}LastTimeColSlowReduce(c, ordinal, start, end)
}

func {{.Name}}LastTimeColMerge(prevPoint, currPoint *{{.Name}}Point) {
    {{- if ne .Name "String"}}
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
	    (currPoint.time == prevPoint.time && currPoint.value > prevPoint.value) {
    {{- else}}
    if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
        (currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
    {{- end}}
		prevPoint.Assign(currPoint)
	}
}
{{- end}}
{{end}}

func BooleanLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
    // fast path
    lastValue, lastIndex := c.Column(ordinal).BooleanValue(start), start
    // column time is not initialized in the subquery
    if len(c.Column(ordinal).ColumnTimes()) == 0 {
        for i := start; i < end; i++ {
            v := c.Column(ordinal).BooleanValue(i)
            if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
                (c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
                lastIndex = i
                lastValue = v
            }
        }
        return lastIndex, lastValue, false
    }
    // column time is initialized
    for i := start; i < end; i++ {
        v := c.Column(ordinal).BooleanValue(i)
        if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
            (c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v && !lastValue) {
            lastIndex = i
            lastValue = v
        }
    }
    return lastIndex, lastValue, false
}

func BooleanLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).BooleanValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v && !lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastTimeColReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
	    return BooleanLastTimeColFastReduce(c, ordinal, start, end)
	}
	return BooleanLastTimeColSlowReduce(c, ordinal, start, end)
}

func BooleanLastTimeColMerge(prevPoint, currPoint *BooleanPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
	    (currPoint.time == prevPoint.time && currPoint.value && !prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
func {{.Name}}RateFastReduce(c Chunk, ordinal, start, end int) (int, int, {{.Type}}, {{.Type}}, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).{{.Name}}Value(start), start
	lastValue, lastIndex := firstValue, firstIndex
	for i := start; i < end; i++ {
		v := c.Column(ordinal).{{.Name}}Value(i)
		if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
		if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func {{.Name}}RateLowReduce(c Chunk, ordinal, start, end int) (int, int, {{.Type}}, {{.Type}}, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).{{.Name}}Value(vs), c.Column(ordinal).GetTimeIndex(vs)
	lastValue, lastIndex := firstValue, firstIndex
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).{{.Name}}Value(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func {{.Name}}RateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, {{.Type}}, {{.Type}}, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return {{.Name}}RateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return {{.Name}}RateLowReduce(c, ordinal, start, end)
}
{{- end}}
{{end}}

{{range .}}
{{- if and (ne .Name "String") (ne .Name "Boolean")}}
func {{.Name}}IrateFastReduce(c Chunk, ordinal, start, end int) (int, int, {{.Type}}, {{.Type}}, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	if end-start == 1 {
		col := c.Column(ordinal)
		v := col.{{.Name}}Value(start)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv {{.Type}}
	)
	if c.TimeByIndex(start) < c.TimeByIndex(start+1) || (c.TimeByIndex(start) == c.TimeByIndex(start+1) && fv > sv) {
		fi, si, fv, sv = start, start+1, c.Column(ordinal).{{.Name}}Value(start), c.Column(ordinal).{{.Name}}Value(start+1)
	} else {
		fi, si, fv, sv = start+1, start, c.Column(ordinal).{{.Name}}Value(start+1), c.Column(ordinal).{{.Name}}Value(start)
	}
	if end-start == 2 {
		return fi, si, fv, sv, false
	}
	for i := start + 2; i < end; i++ {
		v := c.Column(ordinal).{{.Name}}Value(i)
		if c.TimeByIndex(i) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v < fv) {
			continue
		}
		if c.TimeByIndex(i) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(i) > c.TimeByIndex(si) ||
				(c.TimeByIndex(i) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = i, v
			} else {
				fi, fv = i, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func {{.Name}}IrateSlowReduce(c Chunk, ordinal, start, end int) (int, int, {{.Type}}, {{.Type}}, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	if ve-vs == 1 {
		col := c.Column(ordinal)
		v := col.{{.Name}}Value(vs)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv {{.Type}}
	)
	col := c.Column(ordinal)
	fv, sv = col.{{.Name}}Value(vs), col.{{.Name}}Value(vs+1)
	fi, si = col.GetTimeIndex(vs), col.GetTimeIndex(vs+1)
	if !(c.TimeByIndex(fi) < c.TimeByIndex(si) || (c.TimeByIndex(fi) == c.TimeByIndex(si) && fv > sv)) {
		fi, si, fv, sv = si, fi, sv, fv
	}
	if ve-vs == 2 {
		return fi, si, fv, sv, false
	}
	for i := vs + 2; i < ve; i++ {
		v, index := c.Column(ordinal).{{.Name}}Value(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			continue
		}
		if c.TimeByIndex(index) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(index) > c.TimeByIndex(si) ||
				(c.TimeByIndex(index) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = index, v
			} else {
				fi, fv = index, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func {{.Name}}IrateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, {{.Type}}, {{.Type}}, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return {{.Name}}IrateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return {{.Name}}IrateSlowReduce(c, ordinal, start, end)
}

func {{.Name}}IrateFinalReduce(ft int64, st int64, fv {{.Type}}, sv {{.Type}},
	interval *hybridqp.Interval) (float64, bool) {
	if st == ft || interval.Duration == 0 {
		return 0, true
	}
	rate := float64(sv-fv) / (float64(st-ft) / float64(interval.Duration))
	return rate, false
}
{{- end}}
{{end}}

{{range .}}
{{- if and (ne .Name "String")}}
func {{.Name}}SlidingWindowMergeFunc(prevWindow, currWindow *{{.Name}}SlidingWindow, fpm {{.Name}}PointMerge) {
	for i := 0; i < prevWindow.Len(); i++ {
		fpm(prevWindow.points[i], currWindow.points[i])
	}
}
{{- end}}
{{end}}



