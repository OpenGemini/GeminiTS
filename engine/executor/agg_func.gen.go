// Code generated by tmpl; DO NOT EDIT.
// https://github.com/benbjohnson/tmpl
//
// Source: agg_func.gen.go.tmpl

/*
Copyright 2022 Huawei Cloud Computing Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package executor

import (
	"bytes"
)

func FloatLastReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).FloatValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	lastValue, lastIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func IntegerLastReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).IntegerValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	lastValue, lastIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func StringLastReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).StringValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).StringValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, "", true
	}
	lastValue, lastIndex := c.Column(ordinal).StringValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).StringValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func StringLastMerge(prevPoint, currPoint *StringPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
		prevPoint.Assign(currPoint)
	}
}

func BooleanLastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		lastValue, lastIndex := c.Column(ordinal).BooleanValue(start), start
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}

	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).BooleanValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v && !lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastMerge(prevPoint, currPoint *Point[bool]) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value && !prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func FloatFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).FloatValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func FloatFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).FloatValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).FloatValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func FloatFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return FloatFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return FloatFirstTimeColSlowReduce(c, ordinal, start, end)
}

func IntegerFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func IntegerFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).IntegerValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func IntegerFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return IntegerFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return IntegerFirstTimeColSlowReduce(c, ordinal, start, end)
}

func StringFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).StringValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).StringValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func StringFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, "", true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).StringValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).StringValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).StringValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func StringFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return StringFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return StringFirstTimeColSlowReduce(c, ordinal, start, end)
}

func StringFirstTimeColMerge(prevPoint, currPoint *StringPoint) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
		prevPoint.Assign(currPoint)
	}
}

func BooleanFirstTimeColFastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// fast path
	firstValue, firstIndex := c.Column(ordinal).BooleanValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && !v && firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	for i := start; i < end; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && !v && firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func BooleanFirstTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		firstValue, firstIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).BooleanValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && !v && firstValue) {
				firstIndex = i
				firstValue = v
			}
		}
		return firstIndex, firstValue, false
	}
	// column time is initialized
	firstValue, firstIndex := c.Column(ordinal).BooleanValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) < c.Column(ordinal).ColumnTime(firstIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(firstIndex) && !v && firstValue) {
			firstIndex = i
			firstValue = v
		}
	}
	return firstIndex, firstValue, false
}

func BooleanFirstTimeColReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return BooleanFirstTimeColFastReduce(c, ordinal, start, end)
	}
	return BooleanFirstTimeColSlowReduce(c, ordinal, start, end)
}

func BooleanFirstTimeColMerge(prevPoint, currPoint *Point[bool]) {
	if prevPoint.isNil || (currPoint.time < prevPoint.time) ||
		(currPoint.time == prevPoint.time && !currPoint.value && prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func FloatLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).FloatValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).FloatValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func FloatLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).FloatValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).FloatValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func FloatLastTimeColReduce(c Chunk, ordinal, start, end int) (int, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return FloatLastTimeColFastReduce(c, ordinal, start, end)
	}
	return FloatLastTimeColSlowReduce(c, ordinal, start, end)
}

func IntegerLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).IntegerValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).IntegerValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func IntegerLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, 0, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).IntegerValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).IntegerValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func IntegerLastTimeColReduce(c Chunk, ordinal, start, end int) (int, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return IntegerLastTimeColFastReduce(c, ordinal, start, end)
	}
	return IntegerLastTimeColSlowReduce(c, ordinal, start, end)
}

func StringLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).StringValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).StringValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func StringLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, "", true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).StringValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).StringValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).StringValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).StringValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func StringLastTimeColReduce(c Chunk, ordinal, start, end int) (int, string, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return StringLastTimeColFastReduce(c, ordinal, start, end)
	}
	return StringLastTimeColSlowReduce(c, ordinal, start, end)
}

func StringLastTimeColMerge(prevPoint, currPoint *StringPoint) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && bytes.Compare(currPoint.value, prevPoint.value) > 0) {
		prevPoint.Assign(currPoint)
	}
}

func BooleanLastTimeColFastReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// fast path
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(start), start
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		for i := start; i < end; i++ {
			v := c.Column(ordinal).BooleanValue(i)
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	for i := start; i < end; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v && !lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastTimeColSlowReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	// slow path
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return start, false, true
	}
	// column time is not initialized in the subquery
	if len(c.Column(ordinal).ColumnTimes()) == 0 {
		lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), c.Column(ordinal).GetTimeIndex(vs)
		for i := start; i < end; i++ {
			if c.Column(ordinal).IsNilV2(i) {
				continue
			}
			v := c.Column(ordinal).BooleanValue(c.Column(ordinal).GetValueIndexV2(i))
			if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
				(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v && !lastValue) {
				lastIndex = i
				lastValue = v
			}
		}
		return lastIndex, lastValue, false
	}
	// column time is initialized
	lastValue, lastIndex := c.Column(ordinal).BooleanValue(vs), vs
	for i := vs; i < ve; i++ {
		v := c.Column(ordinal).BooleanValue(i)
		if c.Column(ordinal).ColumnTime(i) > c.Column(ordinal).ColumnTime(lastIndex) ||
			(c.Column(ordinal).ColumnTime(i) == c.Column(ordinal).ColumnTime(lastIndex) && v && !lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return lastIndex, lastValue, false
}

func BooleanLastTimeColReduce(c Chunk, ordinal, start, end int) (int, bool, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		return BooleanLastTimeColFastReduce(c, ordinal, start, end)
	}
	return BooleanLastTimeColSlowReduce(c, ordinal, start, end)
}

func BooleanLastTimeColMerge(prevPoint, currPoint *Point[bool]) {
	if prevPoint.isNil || (currPoint.time > prevPoint.time) ||
		(currPoint.time == prevPoint.time && currPoint.value && !prevPoint.value) {
		prevPoint.Assign(currPoint)
	}
}

func FloatRateFastReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).FloatValue(start), start
	lastValue, lastIndex := firstValue, firstIndex
	for i := start; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
		if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func FloatRateLowReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).FloatValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	lastValue, lastIndex := firstValue, firstIndex
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func FloatRateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return FloatRateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return FloatRateLowReduce(c, ordinal, start, end)
}

func IntegerRateFastReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(start), start
	lastValue, lastIndex := firstValue, firstIndex
	for i := start; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = i
			firstValue = v
		}
		if c.TimeByIndex(i) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(i) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = i
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func IntegerRateLowReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	firstValue, firstIndex := c.Column(ordinal).IntegerValue(vs), c.Column(ordinal).GetTimeIndex(vs)
	lastValue, lastIndex := firstValue, firstIndex
	for i := vs; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(firstIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(firstIndex) && v > firstValue) {
			firstIndex = index
			firstValue = v
		}
		if c.TimeByIndex(index) > c.TimeByIndex(lastIndex) ||
			(c.TimeByIndex(index) == c.TimeByIndex(lastIndex) && v > lastValue) {
			lastIndex = index
			lastValue = v
		}
	}
	return firstIndex, lastIndex, firstValue, lastValue, false
}

func IntegerRateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return IntegerRateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return IntegerRateLowReduce(c, ordinal, start, end)
}

func FloatIrateFastReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	if end-start == 1 {
		col := c.Column(ordinal)
		v := col.FloatValue(start)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv float64
	)
	if c.TimeByIndex(start) < c.TimeByIndex(start+1) || (c.TimeByIndex(start) == c.TimeByIndex(start+1) && fv > sv) {
		fi, si, fv, sv = start, start+1, c.Column(ordinal).FloatValue(start), c.Column(ordinal).FloatValue(start+1)
	} else {
		fi, si, fv, sv = start+1, start, c.Column(ordinal).FloatValue(start+1), c.Column(ordinal).FloatValue(start)
	}
	if end-start == 2 {
		return fi, si, fv, sv, false
	}
	for i := start + 2; i < end; i++ {
		v := c.Column(ordinal).FloatValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v < fv) {
			continue
		}
		if c.TimeByIndex(i) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(i) > c.TimeByIndex(si) ||
				(c.TimeByIndex(i) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = i, v
			} else {
				fi, fv = i, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func FloatIrateSlowReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	if ve-vs == 1 {
		col := c.Column(ordinal)
		v := col.FloatValue(vs)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv float64
	)
	col := c.Column(ordinal)
	fv, sv = col.FloatValue(vs), col.FloatValue(vs+1)
	fi, si = col.GetTimeIndex(vs), col.GetTimeIndex(vs+1)
	if !(c.TimeByIndex(fi) < c.TimeByIndex(si) || (c.TimeByIndex(fi) == c.TimeByIndex(si) && fv > sv)) {
		fi, si, fv, sv = si, fi, sv, fv
	}
	if ve-vs == 2 {
		return fi, si, fv, sv, false
	}
	for i := vs + 2; i < ve; i++ {
		v, index := c.Column(ordinal).FloatValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			continue
		}
		if c.TimeByIndex(index) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(index) > c.TimeByIndex(si) ||
				(c.TimeByIndex(index) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = index, v
			} else {
				fi, fv = index, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func FloatIrateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, float64, float64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return FloatIrateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return FloatIrateSlowReduce(c, ordinal, start, end)
}

func IntegerIrateFastReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if end-start == 0 {
		return 0, 0, 0, 0, true
	}
	if end-start == 1 {
		col := c.Column(ordinal)
		v := col.IntegerValue(start)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv int64
	)
	if c.TimeByIndex(start) < c.TimeByIndex(start+1) || (c.TimeByIndex(start) == c.TimeByIndex(start+1) && fv > sv) {
		fi, si, fv, sv = start, start+1, c.Column(ordinal).IntegerValue(start), c.Column(ordinal).IntegerValue(start+1)
	} else {
		fi, si, fv, sv = start+1, start, c.Column(ordinal).IntegerValue(start+1), c.Column(ordinal).IntegerValue(start)
	}
	if end-start == 2 {
		return fi, si, fv, sv, false
	}
	for i := start + 2; i < end; i++ {
		v := c.Column(ordinal).IntegerValue(i)
		if c.TimeByIndex(i) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v < fv) {
			continue
		}
		if c.TimeByIndex(i) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(i) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(i) > c.TimeByIndex(si) ||
				(c.TimeByIndex(i) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = i, v
			} else {
				fi, fv = i, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func IntegerIrateSlowReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	vs, ve := c.Column(ordinal).GetRangeValueIndexV2(start, end)
	if vs == ve {
		return 0, 0, 0, 0, true
	}
	if ve-vs == 1 {
		col := c.Column(ordinal)
		v := col.IntegerValue(vs)
		return start, start, v, v, false
	}
	var (
		fi, si int
		fv, sv int64
	)
	col := c.Column(ordinal)
	fv, sv = col.IntegerValue(vs), col.IntegerValue(vs+1)
	fi, si = col.GetTimeIndex(vs), col.GetTimeIndex(vs+1)
	if !(c.TimeByIndex(fi) < c.TimeByIndex(si) || (c.TimeByIndex(fi) == c.TimeByIndex(si) && fv > sv)) {
		fi, si, fv, sv = si, fi, sv, fv
	}
	if ve-vs == 2 {
		return fi, si, fv, sv, false
	}
	for i := vs + 2; i < ve; i++ {
		v, index := c.Column(ordinal).IntegerValue(i), c.Column(ordinal).GetTimeIndex(i)
		if c.TimeByIndex(index) < c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			continue
		}
		if c.TimeByIndex(index) > c.TimeByIndex(fi) ||
			(c.TimeByIndex(index) == c.TimeByIndex(fi) && v > fv) {
			if c.TimeByIndex(index) > c.TimeByIndex(si) ||
				(c.TimeByIndex(index) == c.TimeByIndex(si) && v > sv) {
				fi, fv = si, sv
				si, sv = index, v
			} else {
				fi, fv = index, v
			}
		}
	}
	return fi, si, fv, sv, false
}

func IntegerIrateMiddleReduce(c Chunk, ordinal, start, end int) (int, int, int64, int64, bool) {
	if c.Column(ordinal).NilCount() == 0 {
		// fast path
		return IntegerIrateFastReduce(c, ordinal, start, end)
	}

	// slow path
	return IntegerIrateSlowReduce(c, ordinal, start, end)
}
